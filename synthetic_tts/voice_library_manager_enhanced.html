<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Library Manager - Hybrid TTS System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .header h1 {
            color: #4a5568;
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: #718096;
            font-size: 1.2em;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #718096;
            margin-top: 5px;
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .filter-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-group label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #4a5568;
        }

        .filter-group select,
        .filter-group input {
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .filter-group select:focus,
        .filter-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .search-box {
            grid-column: 1 / -1;
        }

        .search-box input {
            width: 100%;
            padding: 15px;
            font-size: 16px;
        }

        .voice-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .voice-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
        }

        .voice-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }

        .voice-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .voice-name {
            font-size: 1.3em;
            font-weight: bold;
            color: #4a5568;
        }

        .voice-category {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .transcript {
            background: #f7fafc;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
            font-style: italic;
            color: #4a5568;
        }

        .audio-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
        }

        .play-button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .play-button:hover {
            transform: scale(1.05);
        }

        .play-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .progress-bar {
            flex: 1;
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.1s;
        }

        .time-display {
            font-size: 0.9em;
            color: #718096;
            min-width: 80px;
            text-align: center;
        }

        .quality-scoring {
            margin: 20px 0;
        }

        .quality-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #4a5568;
        }

        .quality-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .quality-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background: #f7fafc;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.3s;
            cursor: pointer;
        }

        .quality-item:hover {
            border-color: #667eea;
            background: #edf2f7;
        }

        .quality-item.selected {
            border-color: #667eea;
            background: #e6fffa;
        }

        .quality-label {
            font-size: 0.8em;
            color: #718096;
            margin-bottom: 5px;
        }

        .quality-score {
            font-size: 1.2em;
            font-weight: bold;
            color: #4a5568;
        }

        .voice-metadata {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 15px 0;
            font-size: 0.9em;
        }

        .metadata-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .metadata-label {
            color: #718096;
            font-weight: 500;
        }

        .metadata-value {
            color: #4a5568;
            font-weight: 600;
        }

        .actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .action-button {
            padding: 8px 16px;
            border: 2px solid #e2e8f0;
            background: white;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .action-button:hover {
            border-color: #667eea;
            color: #667eea;
        }

        .action-button.primary {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .action-button.primary:hover {
            background: #5a67d8;
        }

        .export-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .export-button {
            background: linear-gradient(45deg, #48bb78, #38a169);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .export-button:hover {
            transform: scale(1.05);
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #718096;
        }

        .no-results {
            text-align: center;
            padding: 50px;
            color: #718096;
            font-size: 1.2em;
        }

        .score-summary {
            background: #f7fafc;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border-left: 4px solid #48bb78;
        }

        .score-summary h4 {
            color: #4a5568;
            margin-bottom: 10px;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }

        .score-average {
            font-weight: bold;
            color: #48bb78;
        }

        .training-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .training-title {
            font-size: 1.5em;
            font-weight: bold;
            color: #4a5568;
            margin-bottom: 15px;
        }

        .training-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .training-stat {
            background: #f7fafc;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .training-stat-number {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }

        .training-stat-label {
            color: #718096;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .voice-grid {
                grid-template-columns: 1fr;
            }
            
            .filter-section {
                grid-template-columns: 1fr;
            }
            
            .quality-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéµ Voice Library Manager</h1>
            <p>Fine-tune and train your custom voices with quality scoring</p>
        </div>

        <div class="stats" id="stats">
            <div class="stat-card">
                <div class="stat-number" id="total-voices">0</div>
                <div class="stat-label">Total Voices</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="scored-voices">0</div>
                <div class="stat-label">Scored Voices</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="avg-quality">0.0</div>
                <div class="stat-label">Avg Quality</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="categories">0</div>
                <div class="stat-label">Categories</div>
            </div>
        </div>

        <div class="controls">
            <div class="filter-section">
                <div class="search-box">
                    <label for="search">üîç Search Voices</label>
                    <input type="text" id="search" placeholder="Search by name, category, or transcript...">
                </div>
                <div class="filter-group">
                    <label for="category-filter">Category</label>
                    <select id="category-filter">
                        <option value="">All Categories</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="quality-filter">Quality Range</label>
                    <select id="quality-filter">
                        <option value="">All Qualities</option>
                        <option value="9-10">Excellent (9-10)</option>
                        <option value="7-8">Good (7-8)</option>
                        <option value="5-6">Fair (5-6)</option>
                        <option value="1-4">Poor (1-4)</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="scored-filter">Scoring Status</label>
                    <select id="scored-filter">
                        <option value="">All Voices</option>
                        <option value="scored">Scored Only</option>
                        <option value="unscored">Unscored Only</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="voice-grid" id="voice-grid">
            <div class="loading">Loading voice library...</div>
        </div>

        <div class="training-section" id="training-section" style="display: none;">
            <div class="training-title">üéØ Training Data Summary</div>
            <div class="training-stats" id="training-stats">
                <!-- Training statistics will be populated here -->
            </div>
            <p>Use the quality scores to identify the best voices for training your custom voice models. Higher scores indicate better quality for fine-tuning.</p>
        </div>

        <div class="export-section">
            <h3>üìä Export Results</h3>
            <p>Export your quality scores and voice library data for training and analysis</p>
            <button class="export-button" onclick="exportData()">Export Voice Library Data</button>
            <button class="export-button" onclick="exportTrainingData()" style="margin-left: 10px; background: linear-gradient(45deg, #ed8936, #dd6b20);">Export Training Data</button>
        </div>
    </div>

    <script>
        // Voice library data
        let voiceLibraryData = null;
        let voiceLibrary = [];
        let filteredVoices = [];
        let currentAudio = null;
        let currentAudioElement = null;

        // Quality scoring criteria
        let qualityCriteria = {
            'Naturalness': { min: 1, max: 10, description: 'How natural the voice sounds' },
            'Clarity': { min: 1, max: 10, description: 'How clear and intelligible the speech is' },
            'Emotion': { min: 1, max: 10, description: 'How well emotions are expressed' },
            'Pitch': { min: 1, max: 10, description: 'Pitch accuracy and variation' },
            'Speed': { min: 1, max: 10, description: 'Speaking rate appropriateness' },
            'Overall': { min: 1, max: 10, description: 'Overall quality assessment' }
        };

        // Initialize the application
        async function init() {
            try {
                await loadVoiceLibraryData();
                setupEventListeners();
                updateStats();
                renderVoiceGrid();
                updateTrainingSection();
            } catch (error) {
                console.error('Error initializing application:', error);
                showError('Failed to load voice library data. Please ensure voice_library_data.json exists.');
            }
        }

        // Load voice library data from JSON file
        async function loadVoiceLibraryData() {
            try {
                const response = await fetch('voice_library_data.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                voiceLibraryData = await response.json();
                voiceLibrary = voiceLibraryData.voices || [];
                filteredVoices = [...voiceLibrary];
                
                // Update quality criteria if available
                if (voiceLibraryData.quality_criteria) {
                    qualityCriteria = voiceLibraryData.quality_criteria;
                }
                
                populateCategoryFilter();
                console.log(`Loaded ${voiceLibrary.length} voices from voice library data`);
            } catch (error) {
                console.error('Error loading voice library data:', error);
                // Fallback to sample data
                voiceLibrary = generateSampleVoiceData();
                filteredVoices = [...voiceLibrary];
                populateCategoryFilter();
            }
        }

        // Generate sample voice data as fallback
        function generateSampleVoiceData() {
            const voices = [];
            const categories = [
                'Basic Synthesis', 'Voice Interpolation', 'Voice Morphing', 
                'Voice Continuum', 'Voice Family', 'Voice Analysis',
                'Emotional Speech', 'Prosody Control', 'Quality Tests'
            ];
            
            for (let i = 1; i <= 50; i++) {
                const category = categories[Math.floor(Math.random() * categories.length)];
                voices.push({
                    id: i,
                    category: category,
                    name: `Sample Voice ${i}`,
                    transcript: 'This is a sample voice for testing the voice library manager.',
                    filename: `sample_${i}.wav`,
                    filepath: `test_audio_output/basic_synthesis/basic_sample_${(i % 3) + 1}.wav`,
                    metadata: {
                        duration: Math.random() * 3 + 2,
                        sample_rate: 22050,
                        pitch: (Math.random() * 1.5 + 0.5).toFixed(2),
                        speed: (Math.random() * 1.5 + 0.5).toFixed(2),
                        emotion: 'neutral',
                        gender: 'neutral'
                    },
                    scores: {},
                    average_score: 0,
                    is_scored: false
                });
            }
            
            return voices;
        }

        // Setup event listeners
        function setupEventListeners() {
            document.getElementById('search').addEventListener('input', filterVoices);
            document.getElementById('category-filter').addEventListener('change', filterVoices);
            document.getElementById('quality-filter').addEventListener('change', filterVoices);
            document.getElementById('scored-filter').addEventListener('change', filterVoices);
        }

        // Populate category filter
        function populateCategoryFilter() {
            const categories = [...new Set(voiceLibrary.map(voice => voice.category))];
            const select = document.getElementById('category-filter');
            
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                select.appendChild(option);
            });
        }

        // Filter voices based on search and filters
        function filterVoices() {
            const searchTerm = document.getElementById('search').value.toLowerCase();
            const categoryFilter = document.getElementById('category-filter').value;
            const qualityFilter = document.getElementById('quality-filter').value;
            const scoredFilter = document.getElementById('scored-filter').value;

            filteredVoices = voiceLibrary.filter(voice => {
                // Search filter
                const matchesSearch = !searchTerm || 
                    voice.name.toLowerCase().includes(searchTerm) ||
                    voice.category.toLowerCase().includes(searchTerm) ||
                    voice.transcript.toLowerCase().includes(searchTerm);

                // Category filter
                const matchesCategory = !categoryFilter || voice.category === categoryFilter;

                // Quality filter
                let matchesQuality = true;
                if (qualityFilter && voice.is_scored) {
                    const [min, max] = qualityFilter.split('-').map(Number);
                    matchesQuality = voice.average_score >= min && voice.average_score <= max;
                }

                // Scored filter
                let matchesScored = true;
                if (scoredFilter === 'scored') {
                    matchesScored = voice.is_scored;
                } else if (scoredFilter === 'unscored') {
                    matchesScored = !voice.is_scored;
                }

                return matchesSearch && matchesCategory && matchesQuality && matchesScored;
            });

            renderVoiceGrid();
        }

        // Render voice grid
        function renderVoiceGrid() {
            const grid = document.getElementById('voice-grid');
            
            if (filteredVoices.length === 0) {
                grid.innerHTML = '<div class="no-results">No voices found matching your criteria.</div>';
                return;
            }

            grid.innerHTML = filteredVoices.map(voice => `
                <div class="voice-card" data-voice-id="${voice.id}">
                    <div class="voice-header">
                        <div class="voice-name">${voice.name}</div>
                        <div class="voice-category">${voice.category}</div>
                    </div>
                    
                    <div class="transcript">"${voice.transcript}"</div>
                    
                    <div class="audio-controls">
                        <button class="play-button" onclick="playAudio(${voice.id})">
                            <span>‚ñ∂Ô∏è</span> Play
                        </button>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-${voice.id}"></div>
                        </div>
                        <div class="time-display" id="time-${voice.id}">0:00 / ${formatTime(voice.metadata.duration)}</div>
                    </div>
                    
                    <div class="voice-metadata">
                        <div class="metadata-item">
                            <span class="metadata-label">Duration:</span>
                            <span class="metadata-value">${voice.metadata.duration.toFixed(1)}s</span>
                        </div>
                        <div class="metadata-item">
                            <span class="metadata-label">Sample Rate:</span>
                            <span class="metadata-value">${voice.metadata.sample_rate}Hz</span>
                        </div>
                        <div class="metadata-item">
                            <span class="metadata-label">Pitch:</span>
                            <span class="metadata-value">${voice.metadata.pitch}x</span>
                        </div>
                        <div class="metadata-item">
                            <span class="metadata-label">Speed:</span>
                            <span class="metadata-value">${voice.metadata.speed}x</span>
                        </div>
                        <div class="metadata-item">
                            <span class="metadata-label">Emotion:</span>
                            <span class="metadata-value">${voice.metadata.emotion}</span>
                        </div>
                        <div class="metadata-item">
                            <span class="metadata-label">Gender:</span>
                            <span class="metadata-value">${voice.metadata.gender}</span>
                        </div>
                    </div>
                    
                    <div class="quality-scoring">
                        <div class="quality-title">Quality Scoring</div>
                        <div class="quality-grid">
                            ${Object.entries(qualityCriteria).map(([criterion, config]) => `
                                <div class="quality-item" onclick="scoreVoice(${voice.id}, '${criterion}')">
                                    <div class="quality-label">${criterion}</div>
                                    <div class="quality-score" id="score-${voice.id}-${criterion}">
                                        ${voice.scores[criterion] || '-'}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        ${voice.is_scored ? `
                            <div class="score-summary">
                                <h4>Average Score: ${voice.average_score.toFixed(1)}/10</h4>
                                <div class="score-item">
                                    <span>Naturalness:</span>
                                    <span>${voice.scores.Naturalness || '-'}</span>
                                </div>
                                <div class="score-item">
                                    <span>Clarity:</span>
                                    <span>${voice.scores.Clarity || '-'}</span>
                                </div>
                                <div class="score-item">
                                    <span>Emotion:</span>
                                    <span>${voice.scores.Emotion || '-'}</span>
                                </div>
                                <div class="score-item">
                                    <span>Pitch:</span>
                                    <span>${voice.scores.Pitch || '-'}</span>
                                </div>
                                <div class="score-item">
                                    <span>Speed:</span>
                                    <span>${voice.scores.Speed || '-'}</span>
                                </div>
                                <div class="score-item">
                                    <span>Overall:</span>
                                    <span>${voice.scores.Overall || '-'}</span>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                    
                    <div class="actions">
                        <button class="action-button" onclick="resetScores(${voice.id})">Reset Scores</button>
                        <button class="action-button primary" onclick="saveVoice(${voice.id})">Save Voice</button>
                    </div>
                </div>
            `).join('');
        }

        // Play audio
        function playAudio(voiceId) {
            const voice = voiceLibrary.find(v => v.id === voiceId);
            if (!voice) return;

            // Stop current audio if playing
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }

            // Create new audio element with correct path
            let audioPath = voice.filepath;
            if (!audioPath.startsWith('http')) {
                // Ensure the path starts with the correct directory
                if (!audioPath.startsWith('test_audio_output/') && !audioPath.startsWith('real_audio_output/')) {
                    audioPath = `./${audioPath}`;
                }
            }
            currentAudio = new Audio(audioPath);
            currentAudioElement = currentAudio;
            
            // Add error handling
            currentAudio.addEventListener('error', (e) => {
                console.error('Audio load error:', e);
                console.error('Failed to load audio file:', audioPath);
                alert(`Failed to load audio file: ${audioPath}`);
            });
            
            // Update play button
            const playButton = document.querySelector(`[onclick="playAudio(${voiceId})"]`);
            playButton.innerHTML = '<span>‚è∏Ô∏è</span> Pause';
            playButton.onclick = () => pauseAudio(voiceId);

            // Update progress
            currentAudio.addEventListener('timeupdate', () => {
                const progress = (currentAudio.currentTime / currentAudio.duration) * 100;
                document.getElementById(`progress-${voiceId}`).style.width = `${progress}%`;
                
                const current = formatTime(currentAudio.currentTime);
                const total = formatTime(currentAudio.duration);
                document.getElementById(`time-${voiceId}`).textContent = `${current} / ${total}`;
            });

            // Reset button when finished
            currentAudio.addEventListener('ended', () => {
                playButton.innerHTML = '<span>‚ñ∂Ô∏è</span> Play';
                playButton.onclick = () => playAudio(voiceId);
                document.getElementById(`progress-${voiceId}`).style.width = '0%';
                document.getElementById(`time-${voiceId}`).textContent = `0:00 / ${formatTime(voice.metadata.duration)}`;
            });

            currentAudio.play();
        }

        // Pause audio
        function pauseAudio(voiceId) {
            if (currentAudio) {
                currentAudio.pause();
                const playButton = document.querySelector(`[onclick="pauseAudio(${voiceId})"]`);
                playButton.innerHTML = '<span>‚ñ∂Ô∏è</span> Play';
                playButton.onclick = () => playAudio(voiceId);
            }
        }

        // Format time
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Score voice
        function scoreVoice(voiceId, criterion) {
            const voice = voiceLibrary.find(v => v.id === voiceId);
            if (!voice) return;

            // Simple scoring interface - in a real app, this would be more sophisticated
            const currentScore = voice.scores[criterion] || 0;
            const newScore = currentScore >= 10 ? 1 : currentScore + 1;
            
            voice.scores[criterion] = newScore;
            voice.is_scored = true;
            
            // Update average score
            const scores = Object.values(voice.scores).filter(s => s > 0);
            voice.average_score = scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;
            
            // Update display
            document.getElementById(`score-${voiceId}-${criterion}`).textContent = newScore;
            
            // Update stats
            updateStats();
            updateTrainingSection();
            
            // Re-render the card to show updated scores
            renderVoiceGrid();
        }

        // Reset scores
        function resetScores(voiceId) {
            const voice = voiceLibrary.find(v => v.id === voiceId);
            if (!voice) return;

            voice.scores = {};
            voice.average_score = 0;
            voice.is_scored = false;
            
            updateStats();
            updateTrainingSection();
            renderVoiceGrid();
        }

        // Save voice
        function saveVoice(voiceId) {
            const voice = voiceLibrary.find(v => v.id === voiceId);
            if (!voice) return;

            // In a real implementation, this would save to a database or file
            console.log('Saving voice:', voice);
            alert(`Voice "${voice.name}" saved successfully!`);
        }

        // Update statistics
        function updateStats() {
            const totalVoices = voiceLibrary.length;
            const scoredVoices = voiceLibrary.filter(v => v.is_scored).length;
            const avgQuality = scoredVoices > 0 ? 
                (voiceLibrary.filter(v => v.is_scored).reduce((sum, v) => sum + v.average_score, 0) / scoredVoices).toFixed(1) : 0;
            const categories = new Set(voiceLibrary.map(v => v.category)).size;

            document.getElementById('total-voices').textContent = totalVoices;
            document.getElementById('scored-voices').textContent = scoredVoices;
            document.getElementById('avg-quality').textContent = avgQuality;
            document.getElementById('categories').textContent = categories;
        }

        // Update training section
        function updateTrainingSection() {
            const scoredVoices = voiceLibrary.filter(v => v.is_scored);
            const highQualityVoices = scoredVoices.filter(v => v.average_score >= 8);
            const mediumQualityVoices = scoredVoices.filter(v => v.average_score >= 6 && v.average_score < 8);
            const lowQualityVoices = scoredVoices.filter(v => v.average_score < 6);
            
            const trainingStats = document.getElementById('training-stats');
            trainingStats.innerHTML = `
                <div class="training-stat">
                    <div class="training-stat-number">${highQualityVoices.length}</div>
                    <div class="training-stat-label">High Quality Voices</div>
                </div>
                <div class="training-stat">
                    <div class="training-stat-number">${mediumQualityVoices.length}</div>
                    <div class="training-stat-label">Medium Quality Voices</div>
                </div>
                <div class="training-stat">
                    <div class="training-stat-number">${lowQualityVoices.length}</div>
                    <div class="training-stat-label">Low Quality Voices</div>
                </div>
                <div class="training-stat">
                    <div class="training-stat-number">${scoredVoices.length}</div>
                    <div class="training-stat-label">Total Scored</div>
                </div>
            `;
            
            // Show training section if there are scored voices
            document.getElementById('training-section').style.display = scoredVoices.length > 0 ? 'block' : 'none';
        }

        // Export data
        function exportData() {
            const data = {
                voices: voiceLibrary,
                statistics: {
                    totalVoices: voiceLibrary.length,
                    scoredVoices: voiceLibrary.filter(v => v.is_scored).length,
                    averageQuality: voiceLibrary.filter(v => v.is_scored).reduce((sum, v) => sum + v.average_score, 0) / voiceLibrary.filter(v => v.is_scored).length || 0,
                    categories: [...new Set(voiceLibrary.map(v => v.category))].length
                },
                exportDate: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `voice_library_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Export training data
        function exportTrainingData() {
            const scoredVoices = voiceLibrary.filter(v => v.is_scored);
            const highQualityVoices = scoredVoices.filter(v => v.average_score >= 8);
            
            const trainingData = {
                high_quality_voices: highQualityVoices,
                all_scored_voices: scoredVoices,
                training_recommendations: {
                    best_voices: highQualityVoices.sort((a, b) => b.average_score - a.average_score).slice(0, 10),
                    categories: [...new Set(highQualityVoices.map(v => v.category))],
                    average_scores_by_category: {}
                },
                exportDate: new Date().toISOString()
            };

            // Calculate average scores by category
            const categories = [...new Set(scoredVoices.map(v => v.category))];
            categories.forEach(category => {
                const categoryVoices = scoredVoices.filter(v => v.category === category);
                const avgScore = categoryVoices.reduce((sum, v) => sum + v.average_score, 0) / categoryVoices.length;
                trainingData.training_recommendations.average_scores_by_category[category] = avgScore.toFixed(2);
            });

            const blob = new Blob([JSON.stringify(trainingData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `training_data_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Show error
        function showError(message) {
            alert('Error: ' + message);
        }

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
