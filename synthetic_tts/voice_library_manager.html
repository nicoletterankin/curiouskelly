<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Library Manager - Hybrid TTS System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .header h1 {
            color: #4a5568;
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: #718096;
            font-size: 1.2em;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #718096;
            margin-top: 5px;
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .filter-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-group label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #4a5568;
        }

        .filter-group select,
        .filter-group input {
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .filter-group select:focus,
        .filter-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .search-box {
            grid-column: 1 / -1;
        }

        .search-box input {
            width: 100%;
            padding: 15px;
            font-size: 16px;
        }

        .voice-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .voice-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
        }

        .voice-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }

        .voice-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .voice-name {
            font-size: 1.3em;
            font-weight: bold;
            color: #4a5568;
        }

        .voice-category {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .transcript {
            background: #f7fafc;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
            font-style: italic;
            color: #4a5568;
        }

        .audio-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
        }

        .play-button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .play-button:hover {
            transform: scale(1.05);
        }

        .play-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .progress-bar {
            flex: 1;
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.1s;
        }

        .time-display {
            font-size: 0.9em;
            color: #718096;
            min-width: 80px;
            text-align: center;
        }

        .quality-scoring {
            margin: 20px 0;
        }

        .quality-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #4a5568;
        }

        .quality-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .quality-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background: #f7fafc;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.3s;
            cursor: pointer;
        }

        .quality-item:hover {
            border-color: #667eea;
            background: #edf2f7;
        }

        .quality-item.selected {
            border-color: #667eea;
            background: #e6fffa;
        }

        .quality-label {
            font-size: 0.8em;
            color: #718096;
            margin-bottom: 5px;
        }

        .quality-score {
            font-size: 1.2em;
            font-weight: bold;
            color: #4a5568;
        }

        .voice-metadata {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 15px 0;
            font-size: 0.9em;
        }

        .metadata-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .metadata-label {
            color: #718096;
            font-weight: 500;
        }

        .metadata-value {
            color: #4a5568;
            font-weight: 600;
        }

        .actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .action-button {
            padding: 8px 16px;
            border: 2px solid #e2e8f0;
            background: white;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .action-button:hover {
            border-color: #667eea;
            color: #667eea;
        }

        .action-button.primary {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .action-button.primary:hover {
            background: #5a67d8;
        }

        .export-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .export-button {
            background: linear-gradient(45deg, #48bb78, #38a169);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .export-button:hover {
            transform: scale(1.05);
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #718096;
        }

        .no-results {
            text-align: center;
            padding: 50px;
            color: #718096;
            font-size: 1.2em;
        }

        .score-summary {
            background: #f7fafc;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border-left: 4px solid #48bb78;
        }

        .score-summary h4 {
            color: #4a5568;
            margin-bottom: 10px;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }

        .score-average {
            font-weight: bold;
            color: #48bb78;
        }

        @media (max-width: 768px) {
            .voice-grid {
                grid-template-columns: 1fr;
            }
            
            .filter-section {
                grid-template-columns: 1fr;
            }
            
            .quality-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéµ Voice Library Manager</h1>
            <p>Fine-tune and train your custom voices with quality scoring</p>
        </div>

        <div class="stats" id="stats">
            <div class="stat-card">
                <div class="stat-number" id="total-voices">0</div>
                <div class="stat-label">Total Voices</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="scored-voices">0</div>
                <div class="stat-label">Scored Voices</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="avg-quality">0.0</div>
                <div class="stat-label">Avg Quality</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="categories">0</div>
                <div class="stat-label">Categories</div>
            </div>
        </div>

        <div class="controls">
            <div class="filter-section">
                <div class="search-box">
                    <label for="search">üîç Search Voices</label>
                    <input type="text" id="search" placeholder="Search by name, category, or transcript...">
                </div>
                <div class="filter-group">
                    <label for="category-filter">Category</label>
                    <select id="category-filter">
                        <option value="">All Categories</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="quality-filter">Quality Range</label>
                    <select id="quality-filter">
                        <option value="">All Qualities</option>
                        <option value="9-10">Excellent (9-10)</option>
                        <option value="7-8">Good (7-8)</option>
                        <option value="5-6">Fair (5-6)</option>
                        <option value="1-4">Poor (1-4)</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="scored-filter">Scoring Status</label>
                    <select id="scored-filter">
                        <option value="">All Voices</option>
                        <option value="scored">Scored Only</option>
                        <option value="unscored">Unscored Only</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="voice-grid" id="voice-grid">
            <div class="loading">Loading voice library...</div>
        </div>

        <div class="export-section">
            <h3>üìä Export Results</h3>
            <p>Export your quality scores and voice library data for training and analysis</p>
            <button class="export-button" onclick="exportData()">Export Voice Library Data</button>
        </div>
    </div>

    <script>
        // Voice library data structure
        let voiceLibrary = [];
        let filteredVoices = [];
        let currentAudio = null;
        let currentAudioElement = null;

        // Quality scoring criteria
        const qualityCriteria = {
            'Naturalness': { min: 1, max: 10, description: 'How natural the voice sounds' },
            'Clarity': { min: 1, max: 10, description: 'How clear and intelligible the speech is' },
            'Emotion': { min: 1, max: 10, description: 'How well emotions are expressed' },
            'Pitch': { min: 1, max: 10, description: 'Pitch accuracy and variation' },
            'Speed': { min: 1, max: 10, description: 'Speaking rate appropriateness' },
            'Overall': { min: 1, max: 10, description: 'Overall quality assessment' }
        };

        // Initialize the application
        async function init() {
            await loadVoiceLibrary();
            setupEventListeners();
            updateStats();
            renderVoiceGrid();
        }

        // Load voice library data
        async function loadVoiceLibrary() {
            try {
                // In a real implementation, this would load from your actual audio files
                // For now, we'll generate sample data based on the file structure
                voiceLibrary = generateSampleVoiceData();
                filteredVoices = [...voiceLibrary];
                populateCategoryFilter();
            } catch (error) {
                console.error('Error loading voice library:', error);
                showError('Failed to load voice library data');
            }
        }

        // Generate sample voice data based on the file structure
        function generateSampleVoiceData() {
            const voices = [];
            const categories = [
                'Basic Synthesis', 'Voice Interpolation', 'Voice Morphing', 
                'Voice Continuum', 'Voice Family', 'Voice Analysis',
                'Emotional Speech', 'Prosody Control', 'Quality Tests'
            ];
            
            const emotions = ['neutral', 'happy', 'sad', 'angry', 'excited', 'calm'];
            const prosodyTypes = ['low', 'normal', 'high', 'dramatic', 'urgent'];
            const qualityLevels = ['low', 'medium', 'high', 'studio'];
            
            let id = 1;
            
            // Generate basic synthesis voices
            for (let i = 1; i <= 9; i++) {
                voices.push(createVoiceData(id++, 'Basic Synthesis', `Voice ${i}`, 
                    'Hello, this is a basic synthesis test using the hybrid TTS system.', 
                    'basic_voice_1_1.wav'));
            }
            
            // Generate interpolation voices
            for (let i = 1; i <= 45; i++) {
                const weight = ((i - 1) % 5) * 0.25;
                voices.push(createVoiceData(id++, 'Voice Interpolation', 
                    `Interpolation ${i}`, 
                    'This is voice interpolation between two different voices in real-time.', 
                    `interpolation_voice_1_voice_2_${i}_weight_${weight.toFixed(2)}.wav`));
            }
            
            // Generate morphing voices
            for (let i = 1; i <= 36; i++) {
                const step = (i - 1) % 6;
                voices.push(createVoiceData(id++, 'Voice Morphing', 
                    `Morphing ${i}`, 
                    'Voice morphing transforms one voice into another with precision.', 
                    `morphing_voice_1_voice_2_${i}_step_${step}.wav`));
            }
            
            // Generate continuum voices
            for (let i = 1; i <= 60; i++) {
                const step = (i - 1) % 10;
                voices.push(createVoiceData(id++, 'Voice Continuum', 
                    `Continuum ${i}`, 
                    'Voice continuum creates smooth voice transitions across the voice space.', 
                    `continuum_voice_1_voice_2_${i}_step_${step.toString().padStart(2, '0')}.wav`));
            }
            
            // Generate family voices
            for (let i = 1; i <= 48; i++) {
                voices.push(createVoiceData(id++, 'Voice Family', 
                    `Family Member ${i}`, 
                    'Voice family members share similar characteristics and traits.', 
                    `family_voice_1_${i}_size_3_member_1.wav`));
            }
            
            // Generate emotional voices
            for (let i = 1; i <= 72; i++) {
                const emotion = emotions[(i - 1) % emotions.length];
                voices.push(createVoiceData(id++, 'Emotional Speech', 
                    `${emotion.charAt(0).toUpperCase() + emotion.slice(1)} Voice ${i}`, 
                    'I am so excited about this new technology!', 
                    `emotion_${emotion}_voice_1_${i}.wav`));
            }
            
            // Generate prosody voices
            for (let i = 1; i <= 45; i++) {
                const prosody = prosodyTypes[(i - 1) % prosodyTypes.length];
                voices.push(createVoiceData(id++, 'Prosody Control', 
                    `${prosody.charAt(0).toUpperCase() + prosody.slice(1)} Voice ${i}`, 
                    'The quick brown fox jumps over the lazy dog.', 
                    `prosody_${prosody}_voice_1_${i}.wav`));
            }
            
            // Generate quality test voices
            for (let i = 1; i <= 4; i++) {
                const quality = qualityLevels[i - 1];
                voices.push(createVoiceData(id++, 'Quality Tests', 
                    `${quality.charAt(0).toUpperCase() + quality.slice(1)} Quality`, 
                    'This is a quality test sample for the hybrid TTS system.', 
                    `quality_${quality}_quality.wav`));
            }
            
            return voices;
        }

        // Create individual voice data
        function createVoiceData(id, category, name, transcript, filename) {
            return {
                id: id,
                category: category,
                name: name,
                transcript: transcript,
                filename: filename,
                filepath: `real_audio_output/${category.toLowerCase().replace(' ', '_')}/${filename}`,
                metadata: {
                    duration: Math.random() * 3 + 2, // 2-5 seconds
                    sampleRate: [16000, 22050, 44100, 48000][Math.floor(Math.random() * 4)],
                    bitDepth: [16, 24, 32][Math.floor(Math.random() * 3)],
                    pitch: (Math.random() * 1.5 + 0.5).toFixed(2),
                    speed: (Math.random() * 1.5 + 0.5).toFixed(2),
                    emotion: ['neutral', 'happy', 'sad', 'angry', 'excited', 'calm'][Math.floor(Math.random() * 6)],
                    gender: ['male', 'female', 'neutral'][Math.floor(Math.random() * 3)],
                    age: ['young', 'adult', 'mature'][Math.floor(Math.random() * 3)]
                },
                scores: {},
                averageScore: 0,
                isScored: false
            };
        }

        // Setup event listeners
        function setupEventListeners() {
            document.getElementById('search').addEventListener('input', filterVoices);
            document.getElementById('category-filter').addEventListener('change', filterVoices);
            document.getElementById('quality-filter').addEventListener('change', filterVoices);
            document.getElementById('scored-filter').addEventListener('change', filterVoices);
        }

        // Populate category filter
        function populateCategoryFilter() {
            const categories = [...new Set(voiceLibrary.map(voice => voice.category))];
            const select = document.getElementById('category-filter');
            
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                select.appendChild(option);
            });
        }

        // Filter voices based on search and filters
        function filterVoices() {
            const searchTerm = document.getElementById('search').value.toLowerCase();
            const categoryFilter = document.getElementById('category-filter').value;
            const qualityFilter = document.getElementById('quality-filter').value;
            const scoredFilter = document.getElementById('scored-filter').value;

            filteredVoices = voiceLibrary.filter(voice => {
                // Search filter
                const matchesSearch = !searchTerm || 
                    voice.name.toLowerCase().includes(searchTerm) ||
                    voice.category.toLowerCase().includes(searchTerm) ||
                    voice.transcript.toLowerCase().includes(searchTerm);

                // Category filter
                const matchesCategory = !categoryFilter || voice.category === categoryFilter;

                // Quality filter
                let matchesQuality = true;
                if (qualityFilter && voice.isScored) {
                    const [min, max] = qualityFilter.split('-').map(Number);
                    matchesQuality = voice.averageScore >= min && voice.averageScore <= max;
                }

                // Scored filter
                let matchesScored = true;
                if (scoredFilter === 'scored') {
                    matchesScored = voice.isScored;
                } else if (scoredFilter === 'unscored') {
                    matchesScored = !voice.isScored;
                }

                return matchesSearch && matchesCategory && matchesQuality && matchesScored;
            });

            renderVoiceGrid();
        }

        // Render voice grid
        function renderVoiceGrid() {
            const grid = document.getElementById('voice-grid');
            
            if (filteredVoices.length === 0) {
                grid.innerHTML = '<div class="no-results">No voices found matching your criteria.</div>';
                return;
            }

            grid.innerHTML = filteredVoices.map(voice => `
                <div class="voice-card" data-voice-id="${voice.id}">
                    <div class="voice-header">
                        <div class="voice-name">${voice.name}</div>
                        <div class="voice-category">${voice.category}</div>
                    </div>
                    
                    <div class="transcript">"${voice.transcript}"</div>
                    
                    <div class="audio-controls">
                        <button class="play-button" onclick="playAudio(${voice.id})">
                            <span>‚ñ∂Ô∏è</span> Play
                        </button>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-${voice.id}"></div>
                        </div>
                        <div class="time-display" id="time-${voice.id}">0:00 / 0:00</div>
                    </div>
                    
                    <div class="voice-metadata">
                        <div class="metadata-item">
                            <span class="metadata-label">Duration:</span>
                            <span class="metadata-value">${voice.metadata.duration.toFixed(1)}s</span>
                        </div>
                        <div class="metadata-item">
                            <span class="metadata-label">Sample Rate:</span>
                            <span class="metadata-value">${voice.metadata.sampleRate}Hz</span>
                        </div>
                        <div class="metadata-item">
                            <span class="metadata-label">Pitch:</span>
                            <span class="metadata-value">${voice.metadata.pitch}x</span>
                        </div>
                        <div class="metadata-item">
                            <span class="metadata-label">Speed:</span>
                            <span class="metadata-value">${voice.metadata.speed}x</span>
                        </div>
                        <div class="metadata-item">
                            <span class="metadata-label">Emotion:</span>
                            <span class="metadata-value">${voice.metadata.emotion}</span>
                        </div>
                        <div class="metadata-item">
                            <span class="metadata-label">Gender:</span>
                            <span class="metadata-value">${voice.metadata.gender}</span>
                        </div>
                    </div>
                    
                    <div class="quality-scoring">
                        <div class="quality-title">Quality Scoring</div>
                        <div class="quality-grid">
                            ${Object.entries(qualityCriteria).map(([criterion, config]) => `
                                <div class="quality-item" onclick="scoreVoice(${voice.id}, '${criterion}')">
                                    <div class="quality-label">${criterion}</div>
                                    <div class="quality-score" id="score-${voice.id}-${criterion}">
                                        ${voice.scores[criterion] || '-'}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        ${voice.isScored ? `
                            <div class="score-summary">
                                <h4>Average Score: ${voice.averageScore.toFixed(1)}/10</h4>
                                <div class="score-item">
                                    <span>Naturalness:</span>
                                    <span>${voice.scores.Naturalness || '-'}</span>
                                </div>
                                <div class="score-item">
                                    <span>Clarity:</span>
                                    <span>${voice.scores.Clarity || '-'}</span>
                                </div>
                                <div class="score-item">
                                    <span>Emotion:</span>
                                    <span>${voice.scores.Emotion || '-'}</span>
                                </div>
                                <div class="score-item">
                                    <span>Pitch:</span>
                                    <span>${voice.scores.Pitch || '-'}</span>
                                </div>
                                <div class="score-item">
                                    <span>Speed:</span>
                                    <span>${voice.scores.Speed || '-'}</span>
                                </div>
                                <div class="score-item">
                                    <span>Overall:</span>
                                    <span>${voice.scores.Overall || '-'}</span>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                    
                    <div class="actions">
                        <button class="action-button" onclick="resetScores(${voice.id})">Reset Scores</button>
                        <button class="action-button primary" onclick="saveVoice(${voice.id})">Save Voice</button>
                    </div>
                </div>
            `).join('');
        }

        // Play audio
        function playAudio(voiceId) {
            const voice = voiceLibrary.find(v => v.id === voiceId);
            if (!voice) return;

            // Stop current audio if playing
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }

            // Create new audio element
            currentAudio = new Audio(voice.filepath);
            currentAudioElement = currentAudio;
            
            // Update play button
            const playButton = document.querySelector(`[onclick="playAudio(${voiceId})"]`);
            playButton.innerHTML = '<span>‚è∏Ô∏è</span> Pause';
            playButton.onclick = () => pauseAudio(voiceId);

            // Update progress
            currentAudio.addEventListener('timeupdate', () => {
                const progress = (currentAudio.currentTime / currentAudio.duration) * 100;
                document.getElementById(`progress-${voiceId}`).style.width = `${progress}%`;
                
                const current = formatTime(currentAudio.currentTime);
                const total = formatTime(currentAudio.duration);
                document.getElementById(`time-${voiceId}`).textContent = `${current} / ${total}`;
            });

            // Reset button when finished
            currentAudio.addEventListener('ended', () => {
                playButton.innerHTML = '<span>‚ñ∂Ô∏è</span> Play';
                playButton.onclick = () => playAudio(voiceId);
                document.getElementById(`progress-${voiceId}`).style.width = '0%';
                document.getElementById(`time-${voiceId}`).textContent = '0:00 / 0:00';
            });

            currentAudio.play();
        }

        // Pause audio
        function pauseAudio(voiceId) {
            if (currentAudio) {
                currentAudio.pause();
                const playButton = document.querySelector(`[onclick="pauseAudio(${voiceId})"]`);
                playButton.innerHTML = '<span>‚ñ∂Ô∏è</span> Play';
                playButton.onclick = () => playAudio(voiceId);
            }
        }

        // Format time
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Score voice
        function scoreVoice(voiceId, criterion) {
            const voice = voiceLibrary.find(v => v.id === voiceId);
            if (!voice) return;

            // Simple scoring interface - in a real app, this would be more sophisticated
            const currentScore = voice.scores[criterion] || 0;
            const newScore = currentScore >= 10 ? 1 : currentScore + 1;
            
            voice.scores[criterion] = newScore;
            voice.isScored = true;
            
            // Update average score
            const scores = Object.values(voice.scores).filter(s => s > 0);
            voice.averageScore = scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;
            
            // Update display
            document.getElementById(`score-${voiceId}-${criterion}`).textContent = newScore;
            
            // Update stats
            updateStats();
            
            // Re-render the card to show updated scores
            renderVoiceGrid();
        }

        // Reset scores
        function resetScores(voiceId) {
            const voice = voiceLibrary.find(v => v.id === voiceId);
            if (!voice) return;

            voice.scores = {};
            voice.averageScore = 0;
            voice.isScored = false;
            
            updateStats();
            renderVoiceGrid();
        }

        // Save voice
        function saveVoice(voiceId) {
            const voice = voiceLibrary.find(v => v.id === voiceId);
            if (!voice) return;

            // In a real implementation, this would save to a database or file
            console.log('Saving voice:', voice);
            alert(`Voice "${voice.name}" saved successfully!`);
        }

        // Update statistics
        function updateStats() {
            const totalVoices = voiceLibrary.length;
            const scoredVoices = voiceLibrary.filter(v => v.isScored).length;
            const avgQuality = scoredVoices > 0 ? 
                (voiceLibrary.filter(v => v.isScored).reduce((sum, v) => sum + v.averageScore, 0) / scoredVoices).toFixed(1) : 0;
            const categories = new Set(voiceLibrary.map(v => v.category)).size;

            document.getElementById('total-voices').textContent = totalVoices;
            document.getElementById('scored-voices').textContent = scoredVoices;
            document.getElementById('avg-quality').textContent = avgQuality;
            document.getElementById('categories').textContent = categories;
        }

        // Export data
        function exportData() {
            const data = {
                voices: voiceLibrary,
                statistics: {
                    totalVoices: voiceLibrary.length,
                    scoredVoices: voiceLibrary.filter(v => v.isScored).length,
                    averageQuality: voiceLibrary.filter(v => v.isScored).reduce((sum, v) => sum + v.averageScore, 0) / voiceLibrary.filter(v => v.isScored).length || 0,
                    categories: [...new Set(voiceLibrary.map(v => v.category))].length
                },
                exportDate: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `voice_library_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Show error
        function showError(message) {
            alert('Error: ' + message);
        }

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
